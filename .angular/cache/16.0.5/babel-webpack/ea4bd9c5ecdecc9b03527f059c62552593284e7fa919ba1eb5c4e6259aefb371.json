{"ast":null,"code":"/**\n * @license Angular v16.0.4\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, Injector, effect, untracked as untracked$1, signal as signal$1, computed as computed$1 } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an injection context. Otherwise, the\n * current `DestroyRef` is injected.\n *\n * @developerPreview\n */\nfunction takeUntilDestroyed(destroyRef) {\n  if (!destroyRef) {\n    assertInInjectionContext(takeUntilDestroyed);\n    destroyRef = inject(DestroyRef);\n  }\n  const destroyed$ = new Observable(observer => {\n    const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n    return unregisterFn;\n  });\n  return source => {\n    return source.pipe(takeUntil(destroyed$));\n  };\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nfunction toObservable(source, options) {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject(1);\n  const watcher = effect(() => {\n    let value;\n    try {\n      value = source();\n    } catch (err) {\n      untracked$1(() => subject.error(err));\n      return;\n    }\n    untracked$1(() => subject.next(value));\n  }, {\n    injector,\n    manualCleanup: true\n  });\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n  return subject.asObservable();\n}\n\n/**\n * Base URL for the error details page.\n *\n * Keep this constant in sync across:\n *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts\n *  - packages/core/src/error_details_base_url.ts\n */\nconst ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.io/errors';\n/**\n * URL for the XSS security documentation.\n */\nconst XSS_SECURITY_URL = 'https://g.co/ng/security#xss';\n\n/**\n * Class that represents a runtime error.\n * Formats and outputs the error message in a consistent way.\n *\n * Example:\n * ```\n *  throw new RuntimeError(\n *    RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\n *    ngDevMode && 'Injector has already been destroyed.');\n * ```\n *\n * Note: the `message` argument contains a descriptive error message as a string in development\n * mode (when the `ngDevMode` is defined). In production mode (after tree-shaking pass), the\n * `message` argument becomes `false`, thus we account for it in the typings and the runtime\n * logic.\n */\nclass RuntimeError extends Error {\n  constructor(code, message) {\n    super(formatRuntimeError(code, message));\n    this.code = code;\n  }\n}\n/**\n * Called to format a runtime error.\n * See additional info on the `message` argument type in the `RuntimeError` class description.\n */\nfunction formatRuntimeError(code, message) {\n  // Error code might be a negative number, which is a special marker that instructs the logic to\n  // generate a link to the error details page on angular.io.\n  // We also prepend `0` to non-compile-time errors.\n  const fullCode = `NG0${Math.abs(code)}`;\n  let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;\n  if (ngDevMode && code < 0) {\n    const addPeriodSeparator = !errorMessage.match(/[.,;!?\\n]$/);\n    const separator = addPeriodSeparator ? '.' : '';\n    errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\n  }\n  return errorMessage;\n}\n\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = Symbol('SIGNAL');\n/**\n * Checks if the given `value` is a reactive `Signal`.\n *\n * @developerPreview\n */\nfunction isSignal(value) {\n  return typeof value === 'function' && value[SIGNAL] !== undefined;\n}\n/**\n * Converts `fn` into a marked signal function (where `isSignal(fn)` will be `true`), and\n * potentially add some set of extra properties (passed as an object record `extraApi`).\n */\nfunction createSignalFromFunction(node, fn, extraApi = {}) {\n  fn[SIGNAL] = node;\n  // Copy properties from `extraApi` to `fn` to complete the desired API of the `Signal`.\n  return Object.assign(fn, extraApi);\n}\n/**\n * The default equality function used for `signal` and `computed`, which treats objects and arrays\n * as never equal, and all other primitive values using identity semantics.\n *\n * This allows signals to hold non-primitive values (arrays, objects, other collections) and still\n * propagate change notification upon explicit mutation without identity change.\n *\n * @developerPreview\n */\nfunction defaultEquals(a, b) {\n  // `Object.is` compares two values using identity semantics which is desired behavior for\n  // primitive values. If `Object.is` determines two values to be equal we need to make sure that\n  // those don't represent objects (we want to make sure that 2 objects are always considered\n  // \"unequal\"). The null check is needed for the special case of JavaScript reporting null values\n  // as objects (`typeof null === 'object'`).\n  return (a === null || typeof a !== 'object') && Object.is(a, b);\n}\n\n// Always use __globalThis if available, which is the spec-defined global variable across all\n// environments, then fallback to __global first, because in Node tests both __global and\n// __window may be defined and _global should be __global in that case. Note: Typeof/Instanceof\n// checks are considered side-effects in Terser. We explicitly mark this as side-effect free:\n// https://github.com/terser/terser/issues/250.\nconst _global = /* @__PURE__ */(() => typeof globalThis !== 'undefined' && globalThis || typeof global !== 'undefined' && global || typeof window !== 'undefined' && window || typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && self)();\nfunction ngDevModeResetPerfCounters() {\n  const locationString = typeof location !== 'undefined' ? location.toString() : '';\n  const newCounters = {\n    namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,\n    firstCreatePass: 0,\n    tNode: 0,\n    tView: 0,\n    rendererCreateTextNode: 0,\n    rendererSetText: 0,\n    rendererCreateElement: 0,\n    rendererAddEventListener: 0,\n    rendererSetAttribute: 0,\n    rendererRemoveAttribute: 0,\n    rendererSetProperty: 0,\n    rendererSetClassName: 0,\n    rendererAddClass: 0,\n    rendererRemoveClass: 0,\n    rendererSetStyle: 0,\n    rendererRemoveStyle: 0,\n    rendererDestroy: 0,\n    rendererDestroyNode: 0,\n    rendererMoveNode: 0,\n    rendererRemoveNode: 0,\n    rendererAppendChild: 0,\n    rendererInsertBefore: 0,\n    rendererCreateComment: 0,\n    hydratedNodes: 0,\n    hydratedComponents: 0,\n    dehydratedViewsRemoved: 0,\n    dehydratedViewsCleanupRuns: 0,\n    componentsSkippedHydration: 0\n  };\n  // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\n  const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n  _global['ngDevMode'] = allowNgDevModeTrue && newCounters;\n  return newCounters;\n}\n/**\n * This function checks to see if the `ngDevMode` has been set. If yes,\n * then we honor it, otherwise we default to dev mode with additional checks.\n *\n * The idea is that unless we are doing production build where we explicitly\n * set `ngDevMode == false` we should be helping the developer by providing\n * as much early warning and errors as possible.\n *\n * `ɵɵdefineComponent` is guaranteed to have been called before any component template functions\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\n * is defined for the entire instruction set.\n *\n * When checking `ngDevMode` on toplevel, always init it before referencing it\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\n *\n * Details on possible values for `ngDevMode` can be found on its docstring.\n *\n * NOTE:\n * - changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\nfunction initNgDevMode() {\n  // The below checks are to ensure that calling `initNgDevMode` multiple times does not\n  // reset the counters.\n  // If the `ngDevMode` is not an object, then it means we have not created the perf counters\n  // yet.\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (typeof ngDevMode !== 'object') {\n      ngDevModeResetPerfCounters();\n    }\n    return typeof ngDevMode !== 'undefined' && !!ngDevMode;\n  }\n  return false;\n}\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n/**\n * A `WeakRef`-compatible reference that fakes the API with a strong reference\n * internally.\n */\nclass LeakyRef {\n  constructor(ref) {\n    this.ref = ref;\n  }\n  deref() {\n    return this.ref;\n  }\n}\n// `WeakRef` is not always defined in every TS environment where Angular is compiled. Instead,\n// read it off of the global context if available.\n// tslint:disable-next-line: no-toplevel-property-access\nlet WeakRefImpl = _global['WeakRef'] ?? LeakyRef;\nfunction newWeakRef(value) {\n  if (typeof ngDevMode !== 'undefined' && ngDevMode && WeakRefImpl === undefined) {\n    throw new Error(`Angular requires a browser which supports the 'WeakRef' API`);\n  }\n  return new WeakRefImpl(value);\n}\nfunction setAlternateWeakRefImpl(impl) {\n  // no-op since the alternate impl is included by default by the framework. Remove once internal\n  // migration is complete.\n}\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n/**\n * Counter tracking the next `ProducerId` or `ConsumerId`.\n */\nlet _nextReactiveId = 0;\n/**\n * Tracks the currently active reactive consumer (or `null` if there is no active\n * consumer).\n */\nlet activeConsumer = null;\n/**\n * Whether the graph is currently propagating change notifications.\n */\nlet inNotificationPhase = false;\nfunction setActiveConsumer(consumer) {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\n/**\n * A node in the reactive graph.\n *\n * Nodes can be producers of reactive values, consumers of other reactive values, or both.\n *\n * Producers are nodes that produce values, and can be depended upon by consumer nodes.\n *\n * Producers expose a monotonic `valueVersion` counter, and are responsible for incrementing this\n * version when their value semantically changes. Some producers may produce their values lazily and\n * thus at times need to be polled for potential updates to their value (and by extension their\n * `valueVersion`). This is accomplished via the `onProducerUpdateValueVersion` method for\n * implemented by producers, which should perform whatever calculations are necessary to ensure\n * `valueVersion` is up to date.\n *\n * Consumers are nodes that depend on the values of producers and are notified when those values\n * might have changed.\n *\n * Consumers do not wrap the reads they consume themselves, but rather can be set as the active\n * reader via `setActiveConsumer`. Reads of producers that happen while a consumer is active will\n * result in those producers being added as dependencies of that consumer node.\n *\n * The set of dependencies of a consumer is dynamic. Implementers expose a monotonically increasing\n * `trackingVersion` counter, which increments whenever the consumer is about to re-run any reactive\n * reads it needs and establish a new set of dependencies as a result.\n *\n * Producers store the last `trackingVersion` they've seen from `Consumer`s which have read them.\n * This allows a producer to identify whether its record of the dependency is current or stale, by\n * comparing the consumer's `trackingVersion` to the version at which the dependency was\n * last observed.\n */\nclass ReactiveNode {\n  constructor() {\n    this.id = _nextReactiveId++;\n    /**\n     * A cached weak reference to this node, which will be used in `ReactiveEdge`s.\n     */\n    this.ref = newWeakRef(this);\n    /**\n     * Edges to producers on which this node depends (in its consumer capacity).\n     */\n    this.producers = new Map();\n    /**\n     * Edges to consumers on which this node depends (in its producer capacity).\n     */\n    this.consumers = new Map();\n    /**\n     * Monotonically increasing counter representing a version of this `Consumer`'s\n     * dependencies.\n     */\n    this.trackingVersion = 0;\n    /**\n     * Monotonically increasing counter which increases when the value of this `Producer`\n     * semantically changes.\n     */\n    this.valueVersion = 0;\n  }\n  /**\n   * Polls dependencies of a consumer to determine if they have actually changed.\n   *\n   * If this returns `false`, then even though the consumer may have previously been notified of a\n   * change, the values of its dependencies have not actually changed and the consumer should not\n   * rerun any reactions.\n   */\n  consumerPollProducersForChange() {\n    for (const [producerId, edge] of this.producers) {\n      const producer = edge.producerNode.deref();\n      if (producer === undefined || edge.atTrackingVersion !== this.trackingVersion) {\n        // This dependency edge is stale, so remove it.\n        this.producers.delete(producerId);\n        producer?.consumers.delete(this.id);\n        continue;\n      }\n      if (producer.producerPollStatus(edge.seenValueVersion)) {\n        // One of the dependencies reports a real value change.\n        return true;\n      }\n    }\n    // No dependency reported a real value change, so the `Consumer` has also not been\n    // impacted.\n    return false;\n  }\n  /**\n   * Notify all consumers of this producer that its value may have changed.\n   */\n  producerMayHaveChanged() {\n    // Prevent signal reads when we're updating the graph\n    const prev = inNotificationPhase;\n    inNotificationPhase = true;\n    try {\n      for (const [consumerId, edge] of this.consumers) {\n        const consumer = edge.consumerNode.deref();\n        if (consumer === undefined || consumer.trackingVersion !== edge.atTrackingVersion) {\n          this.consumers.delete(consumerId);\n          consumer?.producers.delete(this.id);\n          continue;\n        }\n        consumer.onConsumerDependencyMayHaveChanged();\n      }\n    } finally {\n      inNotificationPhase = prev;\n    }\n  }\n  /**\n   * Mark that this producer node has been accessed in the current reactive context.\n   */\n  producerAccessed() {\n    if (inNotificationPhase) {\n      throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? `Assertion error: signal read during notification phase` : '');\n    }\n    if (activeConsumer === null) {\n      return;\n    }\n    // Either create or update the dependency `Edge` in both directions.\n    let edge = activeConsumer.producers.get(this.id);\n    if (edge === undefined) {\n      edge = {\n        consumerNode: activeConsumer.ref,\n        producerNode: this.ref,\n        seenValueVersion: this.valueVersion,\n        atTrackingVersion: activeConsumer.trackingVersion\n      };\n      activeConsumer.producers.set(this.id, edge);\n      this.consumers.set(activeConsumer.id, edge);\n    } else {\n      edge.seenValueVersion = this.valueVersion;\n      edge.atTrackingVersion = activeConsumer.trackingVersion;\n    }\n  }\n  /**\n   * Whether this consumer currently has any producers registered.\n   */\n  get hasProducers() {\n    return this.producers.size > 0;\n  }\n  /**\n   * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n   * based on the current consumer context.\n   */\n  get producerUpdatesAllowed() {\n    return activeConsumer?.consumerAllowSignalWrites !== false;\n  }\n  /**\n   * Checks if a `Producer` has a current value which is different than the value\n   * last seen at a specific version by a `Consumer` which recorded a dependency on\n   * this `Producer`.\n   */\n  producerPollStatus(lastSeenValueVersion) {\n    // `producer.valueVersion` may be stale, but a mismatch still means that the value\n    // last seen by the `Consumer` is also stale.\n    if (this.valueVersion !== lastSeenValueVersion) {\n      return true;\n    }\n    // Trigger the `Producer` to update its `valueVersion` if necessary.\n    this.onProducerUpdateValueVersion();\n    // At this point, we can trust `producer.valueVersion`.\n    return this.valueVersion !== lastSeenValueVersion;\n  }\n}\n\n/**\n * Create a computed `Signal` which derives a reactive value from an expression.\n *\n * @developerPreview\n */\nfunction computed(computation, options) {\n  const node = new ComputedImpl(computation, options?.equal ?? defaultEquals);\n  // Casting here is required for g3, as TS inference behavior is slightly different between our\n  // version/options and g3's.\n  return createSignalFromFunction(node, node.signal.bind(node));\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = Symbol('ERRORED');\n/**\n * A computation, which derives a value from a declarative reactive expression.\n *\n * `Computed`s are both producers and consumers of reactivity.\n */\nclass ComputedImpl extends ReactiveNode {\n  constructor(computation, equal) {\n    super();\n    this.computation = computation;\n    this.equal = equal;\n    /**\n     * Current value of the computation.\n     *\n     * This can also be one of the special values `UNSET`, `COMPUTING`, or `ERRORED`.\n     */\n    this.value = UNSET;\n    /**\n     * If `value` is `ERRORED`, the error caught from the last computation attempt which will\n     * be re-thrown.\n     */\n    this.error = null;\n    /**\n     * Flag indicating that the computation is currently stale, meaning that one of the\n     * dependencies has notified of a potential change.\n     *\n     * It's possible that no dependency has _actually_ changed, in which case the `stale`\n     * state can be resolved without recomputing the value.\n     */\n    this.stale = true;\n    this.consumerAllowSignalWrites = false;\n  }\n  onConsumerDependencyMayHaveChanged() {\n    if (this.stale) {\n      // We've already notified consumers that this value has potentially changed.\n      return;\n    }\n    // Record that the currently cached value may be stale.\n    this.stale = true;\n    // Notify any consumers about the potential change.\n    this.producerMayHaveChanged();\n  }\n  onProducerUpdateValueVersion() {\n    if (!this.stale) {\n      // The current value and its version are already up to date.\n      return;\n    }\n    // The current value is stale. Check whether we need to produce a new one.\n    if (this.value !== UNSET && this.value !== COMPUTING && !this.consumerPollProducersForChange()) {\n      // Even though we were previously notified of a potential dependency update, all of\n      // our dependencies report that they have not actually changed in value, so we can\n      // resolve the stale state without needing to recompute the current value.\n      this.stale = false;\n      return;\n    }\n    // The current value is stale, and needs to be recomputed. It still may not change -\n    // that depends on whether the newly computed value is equal to the old.\n    this.recomputeValue();\n  }\n  recomputeValue() {\n    if (this.value === COMPUTING) {\n      // Our computation somehow led to a cyclic read of itself.\n      throw new Error('Detected cycle in computations.');\n    }\n    const oldValue = this.value;\n    this.value = COMPUTING;\n    // As we're re-running the computation, update our dependent tracking version number.\n    this.trackingVersion++;\n    const prevConsumer = setActiveConsumer(this);\n    let newValue;\n    try {\n      newValue = this.computation();\n    } catch (err) {\n      newValue = ERRORED;\n      this.error = err;\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n    this.stale = false;\n    if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && this.equal(oldValue, newValue)) {\n      // No change to `valueVersion` - old and new values are\n      // semantically equivalent.\n      this.value = oldValue;\n      return;\n    }\n    this.value = newValue;\n    this.valueVersion++;\n  }\n  signal() {\n    // Check if the value needs updating before returning it.\n    this.onProducerUpdateValueVersion();\n    // Record that someone looked at this signal.\n    this.producerAccessed();\n    if (this.value === ERRORED) {\n      throw this.error;\n    }\n    return this.value;\n  }\n}\nfunction defaultThrowError() {\n  throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError() {\n  throwInvalidWriteToSignalErrorFn();\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n  throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\nclass WritableSignalImpl extends ReactiveNode {\n  constructor(value, equal) {\n    super();\n    this.value = value;\n    this.equal = equal;\n    this.consumerAllowSignalWrites = false;\n  }\n  onConsumerDependencyMayHaveChanged() {\n    // This never happens for writable signals as they're not consumers.\n  }\n  onProducerUpdateValueVersion() {\n    // Writable signal value versions are always up to date.\n  }\n  /**\n   * Directly update the value of the signal to a new value, which may or may not be\n   * equal to the previous.\n   *\n   * In the event that `newValue` is semantically equal to the current value, `set` is\n   * a no-op.\n   */\n  set(newValue) {\n    if (!this.producerUpdatesAllowed) {\n      throwInvalidWriteToSignalError();\n    }\n    if (!this.equal(this.value, newValue)) {\n      this.value = newValue;\n      this.valueVersion++;\n      this.producerMayHaveChanged();\n      postSignalSetFn?.();\n    }\n  }\n  /**\n   * Derive a new value for the signal from its current value using the `updater` function.\n   *\n   * This is equivalent to calling `set` on the result of running `updater` on the current\n   * value.\n   */\n  update(updater) {\n    if (!this.producerUpdatesAllowed) {\n      throwInvalidWriteToSignalError();\n    }\n    this.set(updater(this.value));\n  }\n  /**\n   * Calls `mutator` on the current value and assumes that it has been mutated.\n   */\n  mutate(mutator) {\n    if (!this.producerUpdatesAllowed) {\n      throwInvalidWriteToSignalError();\n    }\n    // Mutate bypasses equality checks as it's by definition changing the value.\n    mutator(this.value);\n    this.valueVersion++;\n    this.producerMayHaveChanged();\n    postSignalSetFn?.();\n  }\n  asReadonly() {\n    if (this.readonlySignal === undefined) {\n      this.readonlySignal = createSignalFromFunction(this, () => this.signal());\n    }\n    return this.readonlySignal;\n  }\n  signal() {\n    this.producerAccessed();\n    return this.value;\n  }\n}\n/**\n * Create a `Signal` that can be set or updated directly.\n *\n * @developerPreview\n */\nfunction signal(initialValue, options) {\n  const signalNode = new WritableSignalImpl(initialValue, options?.equal ?? defaultEquals);\n  // Casting here is required for g3, as TS inference behavior is slightly different between our\n  // version/options and g3's.\n  const signalFn = createSignalFromFunction(signalNode, signalNode.signal.bind(signalNode), {\n    set: signalNode.set.bind(signalNode),\n    update: signalNode.update.bind(signalNode),\n    mutate: signalNode.mutate.bind(signalNode),\n    asReadonly: signalNode.asReadonly.bind(signalNode)\n  });\n  return signalFn;\n}\nfunction setPostSignalSetFn(fn) {\n  const prev = postSignalSetFn;\n  postSignalSetFn = fn;\n  return prev;\n}\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n *\n * @developerPreview\n */\nfunction untracked(nonReactiveReadsFn) {\n  const prevConsumer = setActiveConsumer(null);\n  // We are not trying to catch any particular errors here, just making sure that the consumers\n  // stack is restored in case of errors.\n  try {\n    return nonReactiveReadsFn();\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\nconst NOOP_CLEANUP_FN = () => {};\n/**\n * Watches a reactive expression and allows it to be scheduled to re-run\n * when any dependencies notify of a change.\n *\n * `Watch` doesn't run reactive expressions itself, but relies on a consumer-\n * provided scheduling operation to coordinate calling `Watch.run()`.\n */\nclass Watch extends ReactiveNode {\n  constructor(watch, schedule, allowSignalWrites) {\n    super();\n    this.watch = watch;\n    this.schedule = schedule;\n    this.dirty = false;\n    this.cleanupFn = NOOP_CLEANUP_FN;\n    this.registerOnCleanup = cleanupFn => {\n      this.cleanupFn = cleanupFn;\n    };\n    this.consumerAllowSignalWrites = allowSignalWrites;\n  }\n  notify() {\n    if (!this.dirty) {\n      this.schedule(this);\n    }\n    this.dirty = true;\n  }\n  onConsumerDependencyMayHaveChanged() {\n    this.notify();\n  }\n  onProducerUpdateValueVersion() {\n    // Watches are not producers.\n  }\n  /**\n   * Execute the reactive expression in the context of this `Watch` consumer.\n   *\n   * Should be called by the user scheduling algorithm when the provided\n   * `schedule` hook is called by `Watch`.\n   */\n  run() {\n    this.dirty = false;\n    if (this.trackingVersion !== 0 && !this.consumerPollProducersForChange()) {\n      return;\n    }\n    const prevConsumer = setActiveConsumer(this);\n    this.trackingVersion++;\n    try {\n      this.cleanupFn();\n      this.cleanupFn = NOOP_CLEANUP_FN;\n      this.watch(this.registerOnCleanup);\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n  cleanup() {\n    this.cleanupFn();\n  }\n}\nfunction toSignal(source, options) {\n  const requiresCleanup = !options?.manualCleanup;\n  requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n  const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n  // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n  // the same - the returned signal gives values of type `T`.\n  let state;\n  if (options?.requireSync) {\n    // Initially the signal is in a `NoValue` state.\n    state = signal$1({\n      kind: 0 /* StateKind.NoValue */\n    });\n  } else {\n    // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n    state = signal$1({\n      kind: 1 /* StateKind.Value */,\n      value: options?.initialValue\n    });\n  }\n  const sub = source.subscribe({\n    next: value => state.set({\n      kind: 1 /* StateKind.Value */,\n      value\n    }),\n    error: error => state.set({\n      kind: 2 /* StateKind.Error */,\n      error\n    })\n    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n    // \"complete\".\n  });\n\n  if (ngDevMode && options?.requireSync && untracked(state).kind === 0 /* StateKind.NoValue */) {\n    throw new RuntimeError(601 /* RuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n  }\n  // Unsubscribe when the current context is destroyed, if requested.\n  cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n  // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n  // to either values or errors.\n  return computed$1(() => {\n    const current = state();\n    switch (current.kind) {\n      case 1 /* StateKind.Value */:\n        return current.value;\n      case 2 /* StateKind.Error */:\n        throw current.error;\n      case 0 /* StateKind.NoValue */:\n        // This shouldn't really happen because the error is thrown on creation.\n        // TODO(alxhub): use a RuntimeError when we finalize the error semantics\n        throw new RuntimeError(601 /* RuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n  });\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { takeUntilDestroyed, toObservable, toSignal };","map":{"version":3,"names":["assertInInjectionContext","inject","DestroyRef","Injector","effect","untracked","untracked$1","signal","signal$1","computed","computed$1","Observable","ReplaySubject","takeUntil","takeUntilDestroyed","destroyRef","destroyed$","observer","unregisterFn","onDestroy","next","bind","source","pipe","toObservable","options","injector","subject","watcher","value","err","error","manualCleanup","get","destroy","complete","asObservable","ERROR_DETAILS_PAGE_BASE_URL","XSS_SECURITY_URL","RuntimeError","Error","constructor","code","message","formatRuntimeError","fullCode","Math","abs","errorMessage","ngDevMode","addPeriodSeparator","match","separator","SIGNAL","Symbol","isSignal","undefined","createSignalFromFunction","node","fn","extraApi","Object","assign","defaultEquals","a","b","is","_global","globalThis","global","window","self","WorkerGlobalScope","ngDevModeResetPerfCounters","locationString","location","toString","newCounters","namedConstructors","indexOf","firstCreatePass","tNode","tView","rendererCreateTextNode","rendererSetText","rendererCreateElement","rendererAddEventListener","rendererSetAttribute","rendererRemoveAttribute","rendererSetProperty","rendererSetClassName","rendererAddClass","rendererRemoveClass","rendererSetStyle","rendererRemoveStyle","rendererDestroy","rendererDestroyNode","rendererMoveNode","rendererRemoveNode","rendererAppendChild","rendererInsertBefore","rendererCreateComment","hydratedNodes","hydratedComponents","dehydratedViewsRemoved","dehydratedViewsCleanupRuns","componentsSkippedHydration","allowNgDevModeTrue","initNgDevMode","LeakyRef","ref","deref","WeakRefImpl","newWeakRef","setAlternateWeakRefImpl","impl","_nextReactiveId","activeConsumer","inNotificationPhase","setActiveConsumer","consumer","prev","ReactiveNode","id","producers","Map","consumers","trackingVersion","valueVersion","consumerPollProducersForChange","producerId","edge","producer","producerNode","atTrackingVersion","delete","producerPollStatus","seenValueVersion","producerMayHaveChanged","consumerId","consumerNode","onConsumerDependencyMayHaveChanged","producerAccessed","set","hasProducers","size","producerUpdatesAllowed","consumerAllowSignalWrites","lastSeenValueVersion","onProducerUpdateValueVersion","computation","ComputedImpl","equal","UNSET","COMPUTING","ERRORED","stale","recomputeValue","oldValue","prevConsumer","newValue","defaultThrowError","throwInvalidWriteToSignalErrorFn","throwInvalidWriteToSignalError","setThrowInvalidWriteToSignalError","postSignalSetFn","WritableSignalImpl","update","updater","mutate","mutator","asReadonly","readonlySignal","initialValue","signalNode","signalFn","setPostSignalSetFn","nonReactiveReadsFn","NOOP_CLEANUP_FN","Watch","watch","schedule","allowSignalWrites","dirty","cleanupFn","registerOnCleanup","notify","run","cleanup","toSignal","requiresCleanup","cleanupRef","state","requireSync","kind","sub","subscribe","unsubscribe","current"],"sources":["/home/kumar007ambi/state_management_app/node_modules/@angular/core/fesm2022/rxjs-interop.mjs"],"sourcesContent":["/**\n * @license Angular v16.0.4\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, Injector, effect, untracked as untracked$1, signal as signal$1, computed as computed$1 } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an injection context. Otherwise, the\n * current `DestroyRef` is injected.\n *\n * @developerPreview\n */\nfunction takeUntilDestroyed(destroyRef) {\n    if (!destroyRef) {\n        assertInInjectionContext(takeUntilDestroyed);\n        destroyRef = inject(DestroyRef);\n    }\n    const destroyed$ = new Observable(observer => {\n        const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n        return unregisterFn;\n    });\n    return (source) => {\n        return source.pipe(takeUntil(destroyed$));\n    };\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nfunction toObservable(source, options) {\n    !options?.injector && assertInInjectionContext(toObservable);\n    const injector = options?.injector ?? inject(Injector);\n    const subject = new ReplaySubject(1);\n    const watcher = effect(() => {\n        let value;\n        try {\n            value = source();\n        }\n        catch (err) {\n            untracked$1(() => subject.error(err));\n            return;\n        }\n        untracked$1(() => subject.next(value));\n    }, { injector, manualCleanup: true });\n    injector.get(DestroyRef).onDestroy(() => {\n        watcher.destroy();\n        subject.complete();\n    });\n    return subject.asObservable();\n}\n\n/**\n * Base URL for the error details page.\n *\n * Keep this constant in sync across:\n *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts\n *  - packages/core/src/error_details_base_url.ts\n */\nconst ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.io/errors';\n/**\n * URL for the XSS security documentation.\n */\nconst XSS_SECURITY_URL = 'https://g.co/ng/security#xss';\n\n/**\n * Class that represents a runtime error.\n * Formats and outputs the error message in a consistent way.\n *\n * Example:\n * ```\n *  throw new RuntimeError(\n *    RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\n *    ngDevMode && 'Injector has already been destroyed.');\n * ```\n *\n * Note: the `message` argument contains a descriptive error message as a string in development\n * mode (when the `ngDevMode` is defined). In production mode (after tree-shaking pass), the\n * `message` argument becomes `false`, thus we account for it in the typings and the runtime\n * logic.\n */\nclass RuntimeError extends Error {\n    constructor(code, message) {\n        super(formatRuntimeError(code, message));\n        this.code = code;\n    }\n}\n/**\n * Called to format a runtime error.\n * See additional info on the `message` argument type in the `RuntimeError` class description.\n */\nfunction formatRuntimeError(code, message) {\n    // Error code might be a negative number, which is a special marker that instructs the logic to\n    // generate a link to the error details page on angular.io.\n    // We also prepend `0` to non-compile-time errors.\n    const fullCode = `NG0${Math.abs(code)}`;\n    let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;\n    if (ngDevMode && code < 0) {\n        const addPeriodSeparator = !errorMessage.match(/[.,;!?\\n]$/);\n        const separator = addPeriodSeparator ? '.' : '';\n        errorMessage =\n            `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\n    }\n    return errorMessage;\n}\n\n/**\n * Symbol used to tell `Signal`s apart from other functions.\n *\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\n */\nconst SIGNAL = Symbol('SIGNAL');\n/**\n * Checks if the given `value` is a reactive `Signal`.\n *\n * @developerPreview\n */\nfunction isSignal(value) {\n    return typeof value === 'function' && value[SIGNAL] !== undefined;\n}\n/**\n * Converts `fn` into a marked signal function (where `isSignal(fn)` will be `true`), and\n * potentially add some set of extra properties (passed as an object record `extraApi`).\n */\nfunction createSignalFromFunction(node, fn, extraApi = {}) {\n    fn[SIGNAL] = node;\n    // Copy properties from `extraApi` to `fn` to complete the desired API of the `Signal`.\n    return Object.assign(fn, extraApi);\n}\n/**\n * The default equality function used for `signal` and `computed`, which treats objects and arrays\n * as never equal, and all other primitive values using identity semantics.\n *\n * This allows signals to hold non-primitive values (arrays, objects, other collections) and still\n * propagate change notification upon explicit mutation without identity change.\n *\n * @developerPreview\n */\nfunction defaultEquals(a, b) {\n    // `Object.is` compares two values using identity semantics which is desired behavior for\n    // primitive values. If `Object.is` determines two values to be equal we need to make sure that\n    // those don't represent objects (we want to make sure that 2 objects are always considered\n    // \"unequal\"). The null check is needed for the special case of JavaScript reporting null values\n    // as objects (`typeof null === 'object'`).\n    return (a === null || typeof a !== 'object') && Object.is(a, b);\n}\n\n// Always use __globalThis if available, which is the spec-defined global variable across all\n// environments, then fallback to __global first, because in Node tests both __global and\n// __window may be defined and _global should be __global in that case. Note: Typeof/Instanceof\n// checks are considered side-effects in Terser. We explicitly mark this as side-effect free:\n// https://github.com/terser/terser/issues/250.\nconst _global = ( /* @__PURE__ */(() => (typeof globalThis !== 'undefined' && globalThis) ||\n    (typeof global !== 'undefined' && global) || (typeof window !== 'undefined' && window) ||\n    (typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n        self instanceof WorkerGlobalScope && self))());\n\nfunction ngDevModeResetPerfCounters() {\n    const locationString = typeof location !== 'undefined' ? location.toString() : '';\n    const newCounters = {\n        namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,\n        firstCreatePass: 0,\n        tNode: 0,\n        tView: 0,\n        rendererCreateTextNode: 0,\n        rendererSetText: 0,\n        rendererCreateElement: 0,\n        rendererAddEventListener: 0,\n        rendererSetAttribute: 0,\n        rendererRemoveAttribute: 0,\n        rendererSetProperty: 0,\n        rendererSetClassName: 0,\n        rendererAddClass: 0,\n        rendererRemoveClass: 0,\n        rendererSetStyle: 0,\n        rendererRemoveStyle: 0,\n        rendererDestroy: 0,\n        rendererDestroyNode: 0,\n        rendererMoveNode: 0,\n        rendererRemoveNode: 0,\n        rendererAppendChild: 0,\n        rendererInsertBefore: 0,\n        rendererCreateComment: 0,\n        hydratedNodes: 0,\n        hydratedComponents: 0,\n        dehydratedViewsRemoved: 0,\n        dehydratedViewsCleanupRuns: 0,\n        componentsSkippedHydration: 0,\n    };\n    // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\n    const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n    _global['ngDevMode'] = allowNgDevModeTrue && newCounters;\n    return newCounters;\n}\n/**\n * This function checks to see if the `ngDevMode` has been set. If yes,\n * then we honor it, otherwise we default to dev mode with additional checks.\n *\n * The idea is that unless we are doing production build where we explicitly\n * set `ngDevMode == false` we should be helping the developer by providing\n * as much early warning and errors as possible.\n *\n * `ɵɵdefineComponent` is guaranteed to have been called before any component template functions\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\n * is defined for the entire instruction set.\n *\n * When checking `ngDevMode` on toplevel, always init it before referencing it\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\n *\n * Details on possible values for `ngDevMode` can be found on its docstring.\n *\n * NOTE:\n * - changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\nfunction initNgDevMode() {\n    // The below checks are to ensure that calling `initNgDevMode` multiple times does not\n    // reset the counters.\n    // If the `ngDevMode` is not an object, then it means we have not created the perf counters\n    // yet.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (typeof ngDevMode !== 'object') {\n            ngDevModeResetPerfCounters();\n        }\n        return typeof ngDevMode !== 'undefined' && !!ngDevMode;\n    }\n    return false;\n}\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n/**\n * A `WeakRef`-compatible reference that fakes the API with a strong reference\n * internally.\n */\nclass LeakyRef {\n    constructor(ref) {\n        this.ref = ref;\n    }\n    deref() {\n        return this.ref;\n    }\n}\n// `WeakRef` is not always defined in every TS environment where Angular is compiled. Instead,\n// read it off of the global context if available.\n// tslint:disable-next-line: no-toplevel-property-access\nlet WeakRefImpl = _global['WeakRef'] ?? LeakyRef;\nfunction newWeakRef(value) {\n    if (typeof ngDevMode !== 'undefined' && ngDevMode && WeakRefImpl === undefined) {\n        throw new Error(`Angular requires a browser which supports the 'WeakRef' API`);\n    }\n    return new WeakRefImpl(value);\n}\nfunction setAlternateWeakRefImpl(impl) {\n    // no-op since the alternate impl is included by default by the framework. Remove once internal\n    // migration is complete.\n}\n\n// Required as the signals library is in a separate package, so we need to explicitly ensure the\n/**\n * Counter tracking the next `ProducerId` or `ConsumerId`.\n */\nlet _nextReactiveId = 0;\n/**\n * Tracks the currently active reactive consumer (or `null` if there is no active\n * consumer).\n */\nlet activeConsumer = null;\n/**\n * Whether the graph is currently propagating change notifications.\n */\nlet inNotificationPhase = false;\nfunction setActiveConsumer(consumer) {\n    const prev = activeConsumer;\n    activeConsumer = consumer;\n    return prev;\n}\n/**\n * A node in the reactive graph.\n *\n * Nodes can be producers of reactive values, consumers of other reactive values, or both.\n *\n * Producers are nodes that produce values, and can be depended upon by consumer nodes.\n *\n * Producers expose a monotonic `valueVersion` counter, and are responsible for incrementing this\n * version when their value semantically changes. Some producers may produce their values lazily and\n * thus at times need to be polled for potential updates to their value (and by extension their\n * `valueVersion`). This is accomplished via the `onProducerUpdateValueVersion` method for\n * implemented by producers, which should perform whatever calculations are necessary to ensure\n * `valueVersion` is up to date.\n *\n * Consumers are nodes that depend on the values of producers and are notified when those values\n * might have changed.\n *\n * Consumers do not wrap the reads they consume themselves, but rather can be set as the active\n * reader via `setActiveConsumer`. Reads of producers that happen while a consumer is active will\n * result in those producers being added as dependencies of that consumer node.\n *\n * The set of dependencies of a consumer is dynamic. Implementers expose a monotonically increasing\n * `trackingVersion` counter, which increments whenever the consumer is about to re-run any reactive\n * reads it needs and establish a new set of dependencies as a result.\n *\n * Producers store the last `trackingVersion` they've seen from `Consumer`s which have read them.\n * This allows a producer to identify whether its record of the dependency is current or stale, by\n * comparing the consumer's `trackingVersion` to the version at which the dependency was\n * last observed.\n */\nclass ReactiveNode {\n    constructor() {\n        this.id = _nextReactiveId++;\n        /**\n         * A cached weak reference to this node, which will be used in `ReactiveEdge`s.\n         */\n        this.ref = newWeakRef(this);\n        /**\n         * Edges to producers on which this node depends (in its consumer capacity).\n         */\n        this.producers = new Map();\n        /**\n         * Edges to consumers on which this node depends (in its producer capacity).\n         */\n        this.consumers = new Map();\n        /**\n         * Monotonically increasing counter representing a version of this `Consumer`'s\n         * dependencies.\n         */\n        this.trackingVersion = 0;\n        /**\n         * Monotonically increasing counter which increases when the value of this `Producer`\n         * semantically changes.\n         */\n        this.valueVersion = 0;\n    }\n    /**\n     * Polls dependencies of a consumer to determine if they have actually changed.\n     *\n     * If this returns `false`, then even though the consumer may have previously been notified of a\n     * change, the values of its dependencies have not actually changed and the consumer should not\n     * rerun any reactions.\n     */\n    consumerPollProducersForChange() {\n        for (const [producerId, edge] of this.producers) {\n            const producer = edge.producerNode.deref();\n            if (producer === undefined || edge.atTrackingVersion !== this.trackingVersion) {\n                // This dependency edge is stale, so remove it.\n                this.producers.delete(producerId);\n                producer?.consumers.delete(this.id);\n                continue;\n            }\n            if (producer.producerPollStatus(edge.seenValueVersion)) {\n                // One of the dependencies reports a real value change.\n                return true;\n            }\n        }\n        // No dependency reported a real value change, so the `Consumer` has also not been\n        // impacted.\n        return false;\n    }\n    /**\n     * Notify all consumers of this producer that its value may have changed.\n     */\n    producerMayHaveChanged() {\n        // Prevent signal reads when we're updating the graph\n        const prev = inNotificationPhase;\n        inNotificationPhase = true;\n        try {\n            for (const [consumerId, edge] of this.consumers) {\n                const consumer = edge.consumerNode.deref();\n                if (consumer === undefined || consumer.trackingVersion !== edge.atTrackingVersion) {\n                    this.consumers.delete(consumerId);\n                    consumer?.producers.delete(this.id);\n                    continue;\n                }\n                consumer.onConsumerDependencyMayHaveChanged();\n            }\n        }\n        finally {\n            inNotificationPhase = prev;\n        }\n    }\n    /**\n     * Mark that this producer node has been accessed in the current reactive context.\n     */\n    producerAccessed() {\n        if (inNotificationPhase) {\n            throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ?\n                `Assertion error: signal read during notification phase` :\n                '');\n        }\n        if (activeConsumer === null) {\n            return;\n        }\n        // Either create or update the dependency `Edge` in both directions.\n        let edge = activeConsumer.producers.get(this.id);\n        if (edge === undefined) {\n            edge = {\n                consumerNode: activeConsumer.ref,\n                producerNode: this.ref,\n                seenValueVersion: this.valueVersion,\n                atTrackingVersion: activeConsumer.trackingVersion,\n            };\n            activeConsumer.producers.set(this.id, edge);\n            this.consumers.set(activeConsumer.id, edge);\n        }\n        else {\n            edge.seenValueVersion = this.valueVersion;\n            edge.atTrackingVersion = activeConsumer.trackingVersion;\n        }\n    }\n    /**\n     * Whether this consumer currently has any producers registered.\n     */\n    get hasProducers() {\n        return this.producers.size > 0;\n    }\n    /**\n     * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\n     * based on the current consumer context.\n     */\n    get producerUpdatesAllowed() {\n        return activeConsumer?.consumerAllowSignalWrites !== false;\n    }\n    /**\n     * Checks if a `Producer` has a current value which is different than the value\n     * last seen at a specific version by a `Consumer` which recorded a dependency on\n     * this `Producer`.\n     */\n    producerPollStatus(lastSeenValueVersion) {\n        // `producer.valueVersion` may be stale, but a mismatch still means that the value\n        // last seen by the `Consumer` is also stale.\n        if (this.valueVersion !== lastSeenValueVersion) {\n            return true;\n        }\n        // Trigger the `Producer` to update its `valueVersion` if necessary.\n        this.onProducerUpdateValueVersion();\n        // At this point, we can trust `producer.valueVersion`.\n        return this.valueVersion !== lastSeenValueVersion;\n    }\n}\n\n/**\n * Create a computed `Signal` which derives a reactive value from an expression.\n *\n * @developerPreview\n */\nfunction computed(computation, options) {\n    const node = new ComputedImpl(computation, options?.equal ?? defaultEquals);\n    // Casting here is required for g3, as TS inference behavior is slightly different between our\n    // version/options and g3's.\n    return createSignalFromFunction(node, node.signal.bind(node));\n}\n/**\n * A dedicated symbol used before a computed value has been calculated for the first time.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst UNSET = Symbol('UNSET');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * is in progress. Used to detect cycles in computation chains.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst COMPUTING = Symbol('COMPUTING');\n/**\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\n * failed. The thrown error is cached until the computation gets dirty again.\n * Explicitly typed as `any` so we can use it as signal's value.\n */\nconst ERRORED = Symbol('ERRORED');\n/**\n * A computation, which derives a value from a declarative reactive expression.\n *\n * `Computed`s are both producers and consumers of reactivity.\n */\nclass ComputedImpl extends ReactiveNode {\n    constructor(computation, equal) {\n        super();\n        this.computation = computation;\n        this.equal = equal;\n        /**\n         * Current value of the computation.\n         *\n         * This can also be one of the special values `UNSET`, `COMPUTING`, or `ERRORED`.\n         */\n        this.value = UNSET;\n        /**\n         * If `value` is `ERRORED`, the error caught from the last computation attempt which will\n         * be re-thrown.\n         */\n        this.error = null;\n        /**\n         * Flag indicating that the computation is currently stale, meaning that one of the\n         * dependencies has notified of a potential change.\n         *\n         * It's possible that no dependency has _actually_ changed, in which case the `stale`\n         * state can be resolved without recomputing the value.\n         */\n        this.stale = true;\n        this.consumerAllowSignalWrites = false;\n    }\n    onConsumerDependencyMayHaveChanged() {\n        if (this.stale) {\n            // We've already notified consumers that this value has potentially changed.\n            return;\n        }\n        // Record that the currently cached value may be stale.\n        this.stale = true;\n        // Notify any consumers about the potential change.\n        this.producerMayHaveChanged();\n    }\n    onProducerUpdateValueVersion() {\n        if (!this.stale) {\n            // The current value and its version are already up to date.\n            return;\n        }\n        // The current value is stale. Check whether we need to produce a new one.\n        if (this.value !== UNSET && this.value !== COMPUTING &&\n            !this.consumerPollProducersForChange()) {\n            // Even though we were previously notified of a potential dependency update, all of\n            // our dependencies report that they have not actually changed in value, so we can\n            // resolve the stale state without needing to recompute the current value.\n            this.stale = false;\n            return;\n        }\n        // The current value is stale, and needs to be recomputed. It still may not change -\n        // that depends on whether the newly computed value is equal to the old.\n        this.recomputeValue();\n    }\n    recomputeValue() {\n        if (this.value === COMPUTING) {\n            // Our computation somehow led to a cyclic read of itself.\n            throw new Error('Detected cycle in computations.');\n        }\n        const oldValue = this.value;\n        this.value = COMPUTING;\n        // As we're re-running the computation, update our dependent tracking version number.\n        this.trackingVersion++;\n        const prevConsumer = setActiveConsumer(this);\n        let newValue;\n        try {\n            newValue = this.computation();\n        }\n        catch (err) {\n            newValue = ERRORED;\n            this.error = err;\n        }\n        finally {\n            setActiveConsumer(prevConsumer);\n        }\n        this.stale = false;\n        if (oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED &&\n            this.equal(oldValue, newValue)) {\n            // No change to `valueVersion` - old and new values are\n            // semantically equivalent.\n            this.value = oldValue;\n            return;\n        }\n        this.value = newValue;\n        this.valueVersion++;\n    }\n    signal() {\n        // Check if the value needs updating before returning it.\n        this.onProducerUpdateValueVersion();\n        // Record that someone looked at this signal.\n        this.producerAccessed();\n        if (this.value === ERRORED) {\n            throw this.error;\n        }\n        return this.value;\n    }\n}\n\nfunction defaultThrowError() {\n    throw new Error();\n}\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError() {\n    throwInvalidWriteToSignalErrorFn();\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n    throwInvalidWriteToSignalErrorFn = fn;\n}\n\n/**\n * If set, called after `WritableSignal`s are updated.\n *\n * This hook can be used to achieve various effects, such as running effects synchronously as part\n * of setting a signal.\n */\nlet postSignalSetFn = null;\nclass WritableSignalImpl extends ReactiveNode {\n    constructor(value, equal) {\n        super();\n        this.value = value;\n        this.equal = equal;\n        this.consumerAllowSignalWrites = false;\n    }\n    onConsumerDependencyMayHaveChanged() {\n        // This never happens for writable signals as they're not consumers.\n    }\n    onProducerUpdateValueVersion() {\n        // Writable signal value versions are always up to date.\n    }\n    /**\n     * Directly update the value of the signal to a new value, which may or may not be\n     * equal to the previous.\n     *\n     * In the event that `newValue` is semantically equal to the current value, `set` is\n     * a no-op.\n     */\n    set(newValue) {\n        if (!this.producerUpdatesAllowed) {\n            throwInvalidWriteToSignalError();\n        }\n        if (!this.equal(this.value, newValue)) {\n            this.value = newValue;\n            this.valueVersion++;\n            this.producerMayHaveChanged();\n            postSignalSetFn?.();\n        }\n    }\n    /**\n     * Derive a new value for the signal from its current value using the `updater` function.\n     *\n     * This is equivalent to calling `set` on the result of running `updater` on the current\n     * value.\n     */\n    update(updater) {\n        if (!this.producerUpdatesAllowed) {\n            throwInvalidWriteToSignalError();\n        }\n        this.set(updater(this.value));\n    }\n    /**\n     * Calls `mutator` on the current value and assumes that it has been mutated.\n     */\n    mutate(mutator) {\n        if (!this.producerUpdatesAllowed) {\n            throwInvalidWriteToSignalError();\n        }\n        // Mutate bypasses equality checks as it's by definition changing the value.\n        mutator(this.value);\n        this.valueVersion++;\n        this.producerMayHaveChanged();\n        postSignalSetFn?.();\n    }\n    asReadonly() {\n        if (this.readonlySignal === undefined) {\n            this.readonlySignal = createSignalFromFunction(this, () => this.signal());\n        }\n        return this.readonlySignal;\n    }\n    signal() {\n        this.producerAccessed();\n        return this.value;\n    }\n}\n/**\n * Create a `Signal` that can be set or updated directly.\n *\n * @developerPreview\n */\nfunction signal(initialValue, options) {\n    const signalNode = new WritableSignalImpl(initialValue, options?.equal ?? defaultEquals);\n    // Casting here is required for g3, as TS inference behavior is slightly different between our\n    // version/options and g3's.\n    const signalFn = createSignalFromFunction(signalNode, signalNode.signal.bind(signalNode), {\n        set: signalNode.set.bind(signalNode),\n        update: signalNode.update.bind(signalNode),\n        mutate: signalNode.mutate.bind(signalNode),\n        asReadonly: signalNode.asReadonly.bind(signalNode)\n    });\n    return signalFn;\n}\nfunction setPostSignalSetFn(fn) {\n    const prev = postSignalSetFn;\n    postSignalSetFn = fn;\n    return prev;\n}\n\n/**\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\n * can, optionally, return a value.\n *\n * @developerPreview\n */\nfunction untracked(nonReactiveReadsFn) {\n    const prevConsumer = setActiveConsumer(null);\n    // We are not trying to catch any particular errors here, just making sure that the consumers\n    // stack is restored in case of errors.\n    try {\n        return nonReactiveReadsFn();\n    }\n    finally {\n        setActiveConsumer(prevConsumer);\n    }\n}\n\nconst NOOP_CLEANUP_FN = () => { };\n/**\n * Watches a reactive expression and allows it to be scheduled to re-run\n * when any dependencies notify of a change.\n *\n * `Watch` doesn't run reactive expressions itself, but relies on a consumer-\n * provided scheduling operation to coordinate calling `Watch.run()`.\n */\nclass Watch extends ReactiveNode {\n    constructor(watch, schedule, allowSignalWrites) {\n        super();\n        this.watch = watch;\n        this.schedule = schedule;\n        this.dirty = false;\n        this.cleanupFn = NOOP_CLEANUP_FN;\n        this.registerOnCleanup = (cleanupFn) => {\n            this.cleanupFn = cleanupFn;\n        };\n        this.consumerAllowSignalWrites = allowSignalWrites;\n    }\n    notify() {\n        if (!this.dirty) {\n            this.schedule(this);\n        }\n        this.dirty = true;\n    }\n    onConsumerDependencyMayHaveChanged() {\n        this.notify();\n    }\n    onProducerUpdateValueVersion() {\n        // Watches are not producers.\n    }\n    /**\n     * Execute the reactive expression in the context of this `Watch` consumer.\n     *\n     * Should be called by the user scheduling algorithm when the provided\n     * `schedule` hook is called by `Watch`.\n     */\n    run() {\n        this.dirty = false;\n        if (this.trackingVersion !== 0 && !this.consumerPollProducersForChange()) {\n            return;\n        }\n        const prevConsumer = setActiveConsumer(this);\n        this.trackingVersion++;\n        try {\n            this.cleanupFn();\n            this.cleanupFn = NOOP_CLEANUP_FN;\n            this.watch(this.registerOnCleanup);\n        }\n        finally {\n            setActiveConsumer(prevConsumer);\n        }\n    }\n    cleanup() {\n        this.cleanupFn();\n    }\n}\n\nfunction toSignal(source, options) {\n    const requiresCleanup = !options?.manualCleanup;\n    requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n    const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n    // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n    // the same - the returned signal gives values of type `T`.\n    let state;\n    if (options?.requireSync) {\n        // Initially the signal is in a `NoValue` state.\n        state = signal$1({ kind: 0 /* StateKind.NoValue */ });\n    }\n    else {\n        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n        state = signal$1({ kind: 1 /* StateKind.Value */, value: options?.initialValue });\n    }\n    const sub = source.subscribe({\n        next: value => state.set({ kind: 1 /* StateKind.Value */, value }),\n        error: error => state.set({ kind: 2 /* StateKind.Error */, error }),\n        // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n        // \"complete\".\n    });\n    if (ngDevMode && options?.requireSync && untracked(state).kind === 0 /* StateKind.NoValue */) {\n        throw new RuntimeError(601 /* RuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n    // Unsubscribe when the current context is destroyed, if requested.\n    cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n    // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n    // to either values or errors.\n    return computed$1(() => {\n        const current = state();\n        switch (current.kind) {\n            case 1 /* StateKind.Value */:\n                return current.value;\n            case 2 /* StateKind.Error */:\n                throw current.error;\n            case 0 /* StateKind.NoValue */:\n                // This shouldn't really happen because the error is thrown on creation.\n                // TODO(alxhub): use a RuntimeError when we finalize the error semantics\n                throw new RuntimeError(601 /* RuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n        }\n    });\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { takeUntilDestroyed, toObservable, toSignal };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}